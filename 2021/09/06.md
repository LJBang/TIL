# 21.09.06

## 구현 문제
파이썬으로 시험을 칠 경우 1초에 2000만번의 연산을 한다고 생각하면 시간초과를 줄일 수 있다.  

### 상하좌우
(1,1)에서 시작해서 커맨드에 따라 이동한 후 도착점을 출력  
N*N 크기의 맵을 벗어나는 행동은 무시된다.

```python
# 내 코드
def move(_comm, _loc, N):
    if _comm == 'R':
        if _loc[1] >= N:
            pass
        else:
            _loc[1] += 1
    elif _comm == 'L':
        if _loc[1] <= 1:
            pass
        else:
            _loc[1] -= 1
    elif _comm == 'U':
        if _loc[0] <= 1:
            pass
        else:
            _loc[0] += 1
    elif _comm == 'D':
        if _loc[0] >= N:
            pass
        else:
            _loc[0] += 1
    return _loc

if __name__ == '__main__':
    N = int(input())
    loc = [1,1]
    commands = input().split()

    for comm in commands:
        loc = move(comm, loc, N)

    print(loc[0], loc[1])
```
if 문의 향연..

```python
# 책 코드
n = int(input())
x, y = 1, 1
plans = input().split()

# R, L, U, D에 따른 이동방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

# plans의 요소들을 move_types 요소들과 비교
for plan in plans:
    for i in range(len(move_types)):
        if plan == move_types[i]
            nx = x + dx[i]
            ny = y + dy[i]
        
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue
    x, y = nx, ny
print (x, y)
```  
명령 비교할때 리스트의 요소끼리 비교하는거 신박하네요...  

