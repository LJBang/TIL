# 22.04.10
## 운영체제
### 프로세스
실행된 프로그램을 프로세스라 한다.  
프로세스는 각각 독립된 주소공간을 할당받으며 아래와 같은 공간을 갖는다.  
- 코드섹션: 코드 자체를 구성하는 메모리 영역
- 데이터섹션: 전역변수, 정적 변수, 배열 등을 저장하는 영역
- 스택: 지역변수, 매개변수, 리턴 값을 저장하는 영역
- 힙: 동적 할당시 사용되는 영역 
스택과 힙은 공간을 공유하며, 서로의 공간을 침범할 경우 오버플로우가 일어난다.  
한 프로그램의 용양이 클 경우 여러개의 프로세스로 돌릴 수 있다.  

#### 프로세스의 상태
프로세스가 실행되는 동안 상태가 바뀐다.  
- New: 새로운 프로세스가 생성되고 수행을 준비한다.
- Ready: 프로세스가 프로세서에 의해 할당될 때까지 대기한다.
- Running: 명령어들이 CPU위에서 실행된다.
- Waiting: 프로세스가 특정 이벤트가 일어날 때 까지 대기한다.
- Terminated: 프로세스가 실행을 종료한다.

- new -> ready: OS의 허가 아래 상태가 변경된다.
- ready -> running: 스케쥴러가 스케쥴링 방법에 따라 할당한다.
- running -> ready: 인터럽트에 의해 실행중인 프로그램이 대기상태가 된다.
- running -> waiting: I/O 혹은 event wait
- waiting -> ready: I/O 혹은 event의 완료
- running -> terminated: exit 명령

#### PCB
각 프로세스의 정보를 담는 블록  
- 프로세스의 상태(running, waiting 등)
- 프로그램 카운터: 실행할 명령어의 위치를 가리키는 카운터
- CPU register
- CPU 스케쥴링 정보 (우선순위나, 스케쥴링 큐 포인터 등)
- 메모리 관리 정보
- CPU 사용 정보, 시작부터 클락 횟수 등의 정보
- I/O상태 정보

#### 스레드
한 프로세스에 여러개의 프로그램 카운터가 있을 경우 여러개의 명령어가 한번에 실행될 수 있다.  
-> 스레드가 생겼다.  

#### 프로세스 스케쥴링
CPU 사용을 최대화 하기위해서 CPU코어에 빠른 프로세스 스위칭이 필요하다.  
스케쥴러가 그 일을 담당한다.  
스케쥴링 큐를 유지한다.  
- ready queue: 메인 메모리에 모든 프로세스를 두고, 실행 대기
- wait queue: I/O와 같은 이벤트를 대기하는 프로세스의 집합
  
#### context switch
CPU가 한 프로세스에서 다른 프로세스로 전환하는 것.  
실행중인 프로세스의 정보들을 PCB에 저장하고, PCB에서 새로 실행될 프로세스의 정보들을 가져온다.  
스위칭 중에는 CPU가 의미 있는 작업을 하지 못하기 때문에, 오버헤드가 발생한다.  

#### 프로세스 생성
부모 프로세스가 자식 프로세스를 생성한다.  
각각의 프로세스는 고유한 pid를 이용해 구분한다.  
부모와 자식간에는 자원 공유를 할수도, 안할수도 있다(optional)  
부모는 자식 프로세스가 종료될 때 까지 기다린다.  
자식 프로세스는 부모프로세스의 주소공간을 복사해 가져온다.  

#### 프로세스 종료
자식 프로세스가 먼저 종료되어야 한다.  
자식이 종료되었는데, 부모의 wait가 끝나지 않을 경우 -> 좀비  
부모가 먼저 종료될 경우 -> 고아  

#### 프로세스간 통신
각 프로세스들은 독립적이다.  
정보 공유, 계산가속, 모듈성, 편의 등을 위해서 협력이 필요한 경우가 있음.  
프로세스간 통신에는 다양한 방법이 있다.  

##### 공유 메모리
특정 메모리 공간을 프로세스들이 공유하여 사용한다.  
프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 공간을 할당하고,  
해당 공간은 어떤 프로세스든지 접근할 수 있다.  
프로세스간 read, write를 모두 필요로 할 때 사용한다.  
대량의 정보를 다수의 프로세스에게 배포 가능하다.  
IPC방법들 중에 가장 빠르게 작동할 수 있다.  

##### 파이프
통신을 위한 메모리 공간(버퍼)을 생성하여 프로세스가 데이터를 주고 받게끔 한다.  
1. 익명 파이프
   - 통신할 프로세스를 명확하세 알 수 있는 경우에 사용한다. (부모-자식, 형제)
   - 두 개의 프로세스를 연결하고 하나의 프로세스는 데이터를 쓰기만, 다른 하나는 읽기만 할 수 있다.  
   - 즉, 두 개의 파이프를 만들어야 양방향 통신이 가능 -> 낭비가 심하다.  

2. 네임드 파이프
   - 전혀 모르는 상태의 프로세스들 사이의 통신에 사용  
   - FIFO라 불리는 파일을 이용해 통신한다.  
   - 마찬가지로 전이중 통신을 위해서는 두 개의 파이프를 만들어야 한다.  

##### 소켓
네트워크 소켓 통신을 통해 데이터를 공유한다.  
각 프로세스틑 하나의 포트(소켓)를 맡아 데이터를 송수신하는 역할을 진행한다.  
두 프로세스가 서로 확인 과정을 거치면 1 대 1로 데이터를 주고받는다.  
원격에서 프로세스간 데이터를 공유할 때 사용한다.  
전이중 통신이 가능하다.  
서버는(bind, listen, accept), 클라이언트는(connect)  

#### 메세지 큐
입출력 방식은 named 파이프와 동일하다.  
메모리 공간을 사용한다.  
다수의 프로세스간 메시지를 전달 할 수 있음  
사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.  
메시지의 접근을 위해서는 키가 필요하다.  
