# 22.03.31

## 네트워크
### OSI 7계층
피지컬 - 데이터링크 - 네트워크 - 트랜스포트 - 세션 - 프레젠테이션 - 어플리케이션   
#### 7계층을 나누는 이유
통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 수정이 쉽기 때문  
#### 물리
리피터, 케이블, 허브 등  
단지 데이터를 전기적인 신호로 변환해서 주고받는 기능을 진행하는 공간.  
데이터를 전송하는 역할만 진행한다.  
#### 데이터링크 
브릿지, 스위치 등  
물리 계층으로 송 수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할.  
Mac주소를 통해 통신한다. 프레임에 Mac주소를 부여하고 에러검출, 재전송, 흐름제어를 진행한다.  
#### 네트워크
라우터, IP  
데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당  
라우터를 통해 이동할 경로를 선택하여 IP주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다.  
라우팅, 흐름제어, 오류제어, 세그먼테이션 등을 수행한다.  
#### 전송
TCP, UDP  
TCP와 UDP 프로토콜을 통해 통신을 활성화한다. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공해준다.  
- TCP: 신뢰성, 연결지향
- UDP: 비신뢰성, 비연결성, 실시간  
#### 세션
API, Socket  
데이터가 통신하기 위한 논리적 연결을 담당한다.  
TCP/IP세션을 만들고 없애는 책임을 갖는다.  
#### 표현
JPEG, MPEG 등  
데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당한다.  
파일 인코딩, 명령어를 포장, 압축, 암호화한다.  
#### 응용
HTTP, FTP, DNS 등  
최종 목적지. 응용프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.  
사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공한다.  

### TCP(흐름제어, 혼잡제어)
#### TCP통신이란?
- 네트워크 통신에서 신뢰할 수 있는 연결방식
- TCP는 기본적으로 신뢰할 수 없는 네트워크에서 신뢰성을 보장할 수 있도록 하는 프로토콜
- TCP는 network congestion avoidance algorithm 사용  
#### reliable network를 보장한다는 것은 4가지 문제점 존재
- 손실: packet이 손실될 수 있는 문제
- 순서바뀜: packet의 순서가 바뀌는 문제
- congestion: 네트워크가 혼잡한 문제
- Overload: receiver가 overload되는 문제  
#### 전송의 과정
- Application layer: sender application layer가 socket에 data를 씀.
- Transport layer: data를 segment에 감싼 후 network layer에 넘겨줌.
- 그러면 아랫단에서 receiving node로 전송이 된다. 이 때, sender의 send buffer에 data를 저장하고, receiver는 receive buffer에 data를 저장함.  
- application에서 준비가 되면 이 buffer에 있는 것을 읽기 시작함.
- 따라서 flow control의 핵심은 이 receive buffer가 넘치지 않게 하는 것.  
- 따라서 receiver는 RWND(Receive WiNDow) 리시브 버퍼의 남은 공간을 홍보한다.
#### 흐름제어/ 혼잡제어란?
**흐름제어**  
- 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
- Flow Control은 reciever가 packet을 지나치게 많이 받지 않도록 조절하는 것
- 기본 개념은 reciever가 sender에게 현재 자신의 상태를 feedback한다는 점
- 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.
- 수신측에서 제한된 용량을 초과한 이후에 도착하는 데이터는 손실될 수 있으며, 손실될 경우 불필요한 데이터 전송과 응답이 발생하게 된다.
- **Stop and Wait**: 매번 전송한 패킷에 대해서 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
- **Sliding Window**(Go Back N ARQ)
    - 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법 
    - 전송은 되었지만 ACK를 받지 못한 byte의 숫자를 파악하기 위한 프로토콜
    `마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 남은 공간`
    `현재 공중에 떠있는 패킷 수 <= sliding window`
    - 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는 대로 윈도우를 옆으로 옮겨 다음 패킷을 전송.  
    예를 들어 윈도우가 6일때 먼저 6개의 패킷을 보내고, 2개의 패킷에 대해 도착 확인이 된다면 2개만큼 윈도우를 옆으로 옮긴다.  
    - TCP/IP를 사용하는 모든 호스트들은 송신용과 수신용 2개의 윈도우를 갖는다. 호스트들은 실제 데이터를 보내기 전에 3 way handshaking을 통해 수신 호스트의 리시브 윈도우 사이즈에 전송 윈도우 사이즈를 맞춘다.  

**혼잡제어**  
- 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우 자신에게 온 데이터를 모두 처리할수 없게 된다. 이 때 호스트들은 또 다시 재전송을 해야하고, 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시킨다. 이를 방지하기 위해 송신측에서 보내는 데이터 전송속도를 강제로 줄이는데, 이를 혼잡제어라고 한다.
- 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 이를 방지하거나 제거하는 기능을 혼잡제어라 한다.  
- AIMD(Additive Increase / Multiplicative Decrease)
    - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기를 1씩 증가시키며 전송
    - 패킷 전송에 실패하거나 일정시간을 넘으면 속도를 절반으로 줄인다.
    - 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입한 쪽이 처음에는 불리하지만 시간이 흐를 수록 공평해진다.  
    - 초기에 네트워크의 높은 대역폭을 사용하지 목하여 시간이 오래걸리고, 네트워크가 혼잡해질 것을 대비하는 것이 아니라 혼잡해진 뒤에 대역폭을 줄이는 방식이다.
- Slow Start
    - AIMD방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 시작이 느리다.
    - 슬로우 스타트는 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 문제가 없다면 ACK패킷마다 윈도우 크기를 1씩 늘려준다. 한 주기가 끝나면 윈도우 크기가 두배가 된다.
    - 혼잡 현상이 발생하면 윈도우 크기를 1로 떨어뜨린다.
    - 전송속도는 AIMD와 비교해 지수함수 꼴로 증가한다. 
    - 한 번 혼잡현상이 발생하고 나면 네트워크의 수용량을 어느정도 예상할 수 있다.
    - 혼잡현상이 발생했던 윈도우 크기의 절반까지는 지수함수 꼴로 증가시키고 그 이후부터는 1씩 증가시킨다.
- Fast Retransmit
    - TCP의 혼잡 조절에 추가된 정책
    - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK패킷을 보낸다.
    - 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 되고, 이를 감지하는 순간 문제가 되는 순번의 패킷을 재전송해줄 수 있다.
    - 중복된 순번의 패킷을 3개 받으면 재전송을 한다. 혼잡을 감지하고 윈도우 크기를 줄인다.
- Fast Recovery
    - 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 ㅇ낳고 반으로 줄이고 증가시킬때는 선형으로 증가시키는 방법.

### UDP
#### UDP 통신이란?
User Datagram Protocol, 데이터를 데이터그램 단위로 처리하는 프로토콜이다.  
비연결형, 신뢰성 없는 전송 프로토콜이다.  
데이터그램 단위로 쪼개면서 전송을 해야하기 때문에 전송계층이다.  
#### TCP / UDP
1. IP의 역할은 Host to Host만을 지원한다. 장치에서 장치로 이동은 IP로 해결되지만, 하나의 장비 안에서 수많은 프로그램들이 통신을 할 경우에는 IP만으로는 한계가 있다.
2. 또한 IP에서 오류가 발생한다면 ICMP에서 알려준다. 하지만 ICMP는 알려주기만 할 뿐 대처를 못하기 때문에 IP보다 위에서 처리를 해줘야 한다. 
- 1을 해결하기 위해서 포트번호가 나왔고, 2를 해결하기 위해서 TCP와 UDP가 상위 프로토콜로 나왔다.
- ICMP는 인터넷 제어 메시지 프로토콜, 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송받는데 주로 쓰인다.  
- TCP: 데이터의 분실, 중복, 순서를 자동으로 보정해줘서 송수신 데이터의 정확한 전달을 할 수 있도록 해준다.
- UDP: IP가 제공하는 정도의 수준만을 제공하는 간단한 IP 상위 계층의 프로토콜이다. TCP와는 다르게 에러가 날 수도 있고, 재전송이나 순서가 뒤바뀔 수도 있어서 이 경우, 어플리케이션에서 처리해야하는 번거로움이 있으나. 빠르기 때문에 실시간성이 있다.  
#### DNS에서 UDP를 사용하는 이유
- request양이 작다. -> UDP request에 담을 수 있다.
- 3 way hanshaking이 필요없다.
- request에 대한 손실은 application layer에서 제어가 가능하다
- DNS: port 53번
- TCP를 사용할 때도 있는데, 크기가 512가 넘을 때 TCP를 사용한다.  

### 대칭키 / 공개키
#### 대칭키
암호화와 복호화에 같은 암호키를 사용하는 알고리즘  
동일한 키를 주고받기 때문에 매우 빠르다!  
대칭키 전달과정에서 해킹 위험이 있음  
#### 공개키
암호화와 복호화에 사용하는 암호키를 분리한 알고리즘  
자신이 가진 고유한 암호키로만 복호화 할 수 있는 암호키를 대중에 공개함  
1. A가 웹 상에 공개된 B의 공개키를 이용해 평문을 암호화 하여 B에게 보냄
2. B는 자신의 비밀키로 복호화한 평문을 확인, A의 공개키로 응답을 암호화하여 A에게 보냄
3. A는 자신의 비밀키로 암호화된 응답문을 복호화함  
복잡함!  
#### 대칭키와 공개키를 적절히 혼합
SSL의 시초가 됨  
대칭키를 주고받을때만 공개키 방식을 사용하고 이후에는 대칭키 방식으로 통신한다.  
1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄
2. B는 암호문을 받고, 자신의 비밀키로 복호화함
3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄
4. A는 자신의 대칭키로 암호문을 복호화함
5. 앞으로 이 대칭키로 암호화를 통신함.  

### HTTP HTTPS
#### HTTP
인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약  
HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다.  
#### HTTPS
HTTP에서 SSL 프로토콜을 추가해 정보를 암호화하여 C-S가 자원을 주고받는다.  
텍스트를 암호화한다.(공개키 암호화 방식으로)  
#### HTTPS 통신흐름
1. 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.  
2. 신뢰할 수 있는 CA(Certificate Authority, 공개키를 저장해주는 검증된 민간기업)을 선택하고, 관리를 맡긴다.  
3. CA기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA기업의 개인키로 암호화해서 A서버에게 제공한다.  
4. A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS요청이 아닌 요청이 오면 암호화된 인증서를 클라이언트에게 준다.  
5. 클라이언트가 `main.html`을 A서버에 요청했다고 가정했을 때, HTTPS요청이 가니기 때문에 CA기업이 A서버의 정보를 CA기업의 개인키로 암호화한 인증서를 받게 된다.
6. 브라우저는 CA기업의 공개키를 알고 있고, 이를 통해 해독한 뒤 A서버의 공개키를 얻는다. 이제 A서버와 통신을 위해서는 A서버의 공개키로 암호화해서 요청을 보낸다.  

### TLS/SSL HandShake
HTTPS에서 클라이언트와 서버간 통신 전  
SSL인증서로 신뢰성 여부를 판단하기 위해 연결하는 방식  
1. 클라이언트는 서버에게 Client hello 메시지를 담아 서버로 보낸다. 이때 암호화된 정보를 함께 담는데, 버전, 암호 알고리즘, 압축방식 등을 담는다.  
2. 서버는 클라이언트가 보낸 암호 알고리즘과 압축방식을 받고, 세션ID와 CA 공개 인증서를 Server Hello 메시지와 함께 담아 응답한다. 이 CA 인증서에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전, 클라이언트에서 handshake 과정 속 암호화에 사용할 공개키를 담고 있다.  
3. 클라이언트 측은 서버에서 보낸 CA 인증서에 대해 유효한 지 CA 목록에서 확인하는 과정을 거친다.  
4. CA인증서에 대한 신뢰성이 확보되었다면, 클라이언트는 난수 바이트를 생성하여 서버의 공개키로 암호화한다. 이 난수 바이트는 대칭키를 정하는데 사용이되고, 앞으로 서로 메시지를 통신할 때 암호화하는데 사용된다.
5. 만약 2번 단계에서 서버가 클라이언트 인증서를 함께 요구했다면, 클라이언트의 인증서와 클라이언트의 개인키로 암호화된 임의의 바이트 문자열을 함께 보내준다.  
6. 서버는 클라이언트의 인증서를 확인 후, 난수 바이트를 자신의 개인키로 복호화 후 대칭 마스터 키 생성에 활용한다.  
7. 클라이언트는 handshake 과정이 완료되었다는 finished메시지를 서버에 보내면서, 지금까지 보낸 교환 내역들을 해싱 후 그 값을 대칭키로 암호화하여 같이 담아 보내준다.  
8. 서버도 동일하게 교환 내용들을 해싱한 뒤 클라이언트에서 보내준 값과 일치하는 지 확인한다. 일치하면 서버도 마찬가지로 finished 메시지를 이번에 만든 대칭키로 암호화하여 보낸다.  
9. 클라이언트는 해당 메시지를 대칭키로 복호화하여 서로 통신이 가능한 신뢰받은 사용자란 걸 인지하고, 앞으로 클라이언트와 서버는 해당 대칭키로 데이터를 주고받을 수 있게 된다.  
